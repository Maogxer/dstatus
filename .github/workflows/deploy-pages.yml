name: Deploy Binaries to Pages

on:
  workflow_run:
    workflows: ["Build and Release Binary"]
    types:
      - completed
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      branch:
        description: '要部署的分支名称'
        required: true
        default: 'develop'
        type: choice
        options:
          - main
          - develop

# 设置GITHUB_TOKEN的权限
permissions:
  contents: write
  pages: write
  id-token: write

# 允许一个并发部署
concurrency:
  group: "pages"
  cancel-in-progress: true

jobs:
  # 调试工作流信息
  debug-workflow:
    runs-on: ubuntu-latest
    steps:
      - name: 打印工作流信息
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Workflow ref: ${{ github.ref }}"
          echo "Actor: ${{ github.actor }}"
          echo "Triggering workflow: ${{ github.event.workflow.name || 'N/A' }}"
          
          # 如果是workflow_run事件，打印相关信息
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "Workflow run conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Workflow run head branch: ${{ github.event.workflow_run.head_branch }}"
            echo "Workflow run id: ${{ github.event.workflow_run.id }}"
          fi

          # 如果是workflow_dispatch事件，打印相关信息
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "Selected branch: ${{ github.event.inputs.branch }}"
          fi

  # 直接部署开发分支页面（简化流程）
  deploy-dev:
    needs: debug-workflow
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'develop') ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'develop')
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          ref: develop
          fetch-depth: 0

      - name: 打印构件下载信息
        run: |
          echo "尝试从以下运行ID下载构件: ${{ github.event.workflow_run.id || 'manual trigger' }}"
          echo "仓库: ${{ github.repository }}"
          echo "分支: ${{ github.event.workflow_run.head_branch || github.ref }}"
      
      - name: 列出可用的工作流运行
        if: github.event_name == 'workflow_dispatch'
        run: |
          # 安装 GitHub CLI
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo gpg --dearmor -o /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update
          sudo apt install gh -y
          
          # 列出workflow运行
          echo "最近的Build and Release Binary工作流运行:"
          gh run list --workflow "Build and Release Binary" --limit 5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 获取最新的workflow运行ID
        id: get-run-id
        if: github.event_name == 'workflow_dispatch'
        run: |
          # 安装jq
          sudo apt-get update
          sudo apt-get install -y jq
          
          # 使用GitHub API获取最新成功的工作流运行
          REPO="${GITHUB_REPOSITORY}"
          WORKFLOW_FILE="build-release.yml"
          BRANCH="develop"
          
          echo "正在查询最新的工作流运行..."
          RUNS_URL="https://api.github.com/repos/${REPO}/actions/workflows/${WORKFLOW_FILE}/runs?branch=${BRANCH}&status=success&per_page=1"
          
          RESPONSE=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "${RUNS_URL}")
          echo "API响应: $RESPONSE"
          
          LATEST_RUN_ID=$(echo "$RESPONSE" | jq -r '.workflow_runs[0].id')
          
          if [ "$LATEST_RUN_ID" != "null" ] && [ -n "$LATEST_RUN_ID" ]; then
            echo "找到最新的workflow运行ID: $LATEST_RUN_ID"
            echo "latest_run_id=$LATEST_RUN_ID" >> $GITHUB_OUTPUT
          else
            echo "未找到成功的workflow运行"
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 创建工作目录
        run: mkdir -p download-dev public-dev
      
      # 手动下载构件ZIP文件
      - name: 手动下载构件
        if: github.event_name == 'workflow_dispatch'
        run: |
          RUN_ID="${{ steps.get-run-id.outputs.latest_run_id }}"
          ARTIFACT_NAME="neko-status-dev-latest"
          REPO="${GITHUB_REPOSITORY}"
          
          # 获取构件信息
          ARTIFACTS_URL="https://api.github.com/repos/${REPO}/actions/runs/${RUN_ID}/artifacts"
          ARTIFACTS_JSON=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "${ARTIFACTS_URL}")
          
          echo "构件信息: $ARTIFACTS_JSON"
          
          # 获取指定构件的下载URL
          ARTIFACT_ID=$(echo "$ARTIFACTS_JSON" | jq -r ".artifacts[] | select(.name==\"${ARTIFACT_NAME}\") | .id")
          
          if [ -z "$ARTIFACT_ID" ] || [ "$ARTIFACT_ID" == "null" ]; then
            echo "未找到名为 ${ARTIFACT_NAME} 的构件"
            exit 1
          fi
          
          echo "找到构件ID: $ARTIFACT_ID"
          
          # 下载构件
          DOWNLOAD_URL="https://api.github.com/repos/${REPO}/actions/artifacts/${ARTIFACT_ID}/zip"
          echo "下载URL: $DOWNLOAD_URL"
          
          curl -L -o artifact.zip -H "Authorization: token ${GITHUB_TOKEN}" "${DOWNLOAD_URL}"
          
          # 解压构件
          unzip -o artifact.zip -d download-dev
          ls -la download-dev
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # 如果是workflow_run触发，使用标准方法下载
      - name: 使用标准方法下载构件
        if: github.event_name == 'workflow_run'
        uses: actions/download-artifact@v4
        with:
          name: neko-status-dev-latest
          path: download-dev
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
      
      - name: 检查下载的文件
        run: |
          echo "下载目录内容:"
          find download-dev -type f | sort
          echo "文件大小:"
          du -sh download-dev/*

      - name: 准备dev目录
        run: |
          # 创建目标目录
          mkdir -p public-dev
          
          # 检查目录内容
          echo "检查下载目录内容:"
          ls -la download-dev/
          
          # 复制文件（如果存在）
          if [ -f download-dev/neko-status_linux_amd64 ]; then
            # 如果文件直接在download-dev目录下
            echo "直接复制文件..."
            cp download-dev/neko-status_linux_amd64 public-dev/ || echo "linux_amd64文件不存在"
            cp download-dev/neko-status_linux_arm64 public-dev/ || echo "linux_arm64文件不存在" 
            cp download-dev/neko-status_linux_arm7 public-dev/ || echo "linux_arm7文件不存在"
            cp download-dev/neko-status_linux_386 public-dev/ || echo "linux_386文件不存在"
            cp download-dev/neko-status_darwin_amd64 public-dev/ || echo "darwin_amd64文件不存在"
            cp download-dev/neko-status_darwin_arm64 public-dev/ || echo "darwin_arm64文件不存在"
            cp download-dev/neko-status_linux_universal public-dev/neko-status || echo "linux_universal文件不存在"
            cp download-dev/neko-status_darwin_universal public-dev/neko-status_darwin || echo "darwin_universal文件不存在"
            cp download-dev/SHA256SUMS public-dev/ || echo "SHA256SUMS文件不存在"
          else
            # 查找文件实际位置
            echo "查找文件实际位置..."
            LINUX_AMD64_PATH=$(find download-dev -name "neko-status_linux_amd64" -type f)
            LINUX_ARM64_PATH=$(find download-dev -name "neko-status_linux_arm64" -type f)
            LINUX_ARM7_PATH=$(find download-dev -name "neko-status_linux_arm7" -type f)
            LINUX_386_PATH=$(find download-dev -name "neko-status_linux_386" -type f)
            DARWIN_AMD64_PATH=$(find download-dev -name "neko-status_darwin_amd64" -type f)
            DARWIN_ARM64_PATH=$(find download-dev -name "neko-status_darwin_arm64" -type f)
            LINUX_UNIVERSAL_PATH=$(find download-dev -name "neko-status_linux_universal" -type f)
            DARWIN_UNIVERSAL_PATH=$(find download-dev -name "neko-status_darwin_universal" -type f)
            SHA256SUMS_PATH=$(find download-dev -name "SHA256SUMS" -type f)
            
            # 复制找到的文件
            if [ -n "$LINUX_AMD64_PATH" ]; then cp "$LINUX_AMD64_PATH" public-dev/neko-status_linux_amd64; fi
            if [ -n "$LINUX_ARM64_PATH" ]; then cp "$LINUX_ARM64_PATH" public-dev/neko-status_linux_arm64; fi
            if [ -n "$LINUX_ARM7_PATH" ]; then cp "$LINUX_ARM7_PATH" public-dev/neko-status_linux_arm7; fi
            if [ -n "$LINUX_386_PATH" ]; then cp "$LINUX_386_PATH" public-dev/neko-status_linux_386; fi
            if [ -n "$DARWIN_AMD64_PATH" ]; then cp "$DARWIN_AMD64_PATH" public-dev/neko-status_darwin_amd64; fi
            if [ -n "$DARWIN_ARM64_PATH" ]; then cp "$DARWIN_ARM64_PATH" public-dev/neko-status_darwin_arm64; fi
            if [ -n "$LINUX_UNIVERSAL_PATH" ]; then cp "$LINUX_UNIVERSAL_PATH" public-dev/neko-status; fi
            if [ -n "$DARWIN_UNIVERSAL_PATH" ]; then cp "$DARWIN_UNIVERSAL_PATH" public-dev/neko-status_darwin; fi
            if [ -n "$SHA256SUMS_PATH" ]; then cp "$SHA256SUMS_PATH" public-dev/SHA256SUMS; fi
          fi
          
          # 创建版本信息文件
          echo "DEV-$(date +%Y-%m-%d_%H:%M:%S)" > public-dev/version.txt
          
          # 确保文件可执行
          find public-dev -type f -name "neko-status*" -exec chmod +x {} \;
          
          # 列出文件
          echo "公开目录内容:"
          ls -la public-dev/
      
      - name: Deploy to Dev Folder
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          folder: public-dev
          target-folder: dev
          token: ${{ secrets.GITHUB_TOKEN }}
          clean: false

  # 发布到主分支页面
  deploy-main:
    needs: debug-workflow
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'main') ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main')
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      
      - name: Download neko-status artifacts
        uses: actions/download-artifact@v4
        with:
          name: neko-status-latest
          path: download
          github-token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Pages
        uses: actions/configure-pages@v3
      
      - name: Prepare public directory
        run: |
          mkdir -p public
          
          # 检查下载的文件
          echo "下载目录内容:"
          find download -type f | sort
          
          # 复制二进制文件到public目录
          cp download/neko-status_linux_amd64 public/ || echo "linux_amd64文件不存在"
          cp download/neko-status_linux_arm64 public/ || echo "linux_arm64文件不存在"
          cp download/neko-status_linux_arm7 public/ || echo "linux_arm7文件不存在"
          cp download/neko-status_linux_386 public/ || echo "linux_386文件不存在"
          cp download/neko-status_darwin_amd64 public/ || echo "darwin_amd64文件不存在"
          cp download/neko-status_darwin_arm64 public/ || echo "darwin_arm64文件不存在"
          cp download/neko-status_linux_universal public/neko-status || echo "linux_universal文件不存在"
          cp download/neko-status_darwin_universal public/neko-status_darwin || echo "darwin_universal文件不存在"
          cp download/SHA256SUMS public/ || echo "SHA256SUMS文件不存在"
          
          # 创建版本信息文件
          echo "$(date +%Y-%m-%d_%H:%M:%S)" > public/version.txt
          
          # 确保文件可执行
          chmod +x public/neko-status* || echo "没有可执行文件"
          
          # 列出文件
          ls -la public/
      
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v2
        with:
          path: 'public'
      
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v2
